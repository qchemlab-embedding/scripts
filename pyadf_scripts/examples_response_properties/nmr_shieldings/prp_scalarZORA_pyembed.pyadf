#
# This example shows how to calculate the NMR shielding tensor in ADF via pyadf.
# It demonstrates:
# * how to play with different partitioning schemes (selection of subsystems)
# * how to calculate NMR with and without FDE
# * how to do freeze-and-thaw cycles
#
# Note that in "real" examples, you might need to split this script into few
# so that you have enough CPU for each task
#
#
# last. rev. Gosia Olejniczak, 12/03/2024
#


import shutil
import time

##########################################################
# functions grepping key ADF results
##########################################################

def calculate_nmr_shieldings(molecule, results, active_atoms=None, active_labels=None, active_coords=None, label=None, ghost_coords=None, print_active=False, print_ghost=False):

    print( " # " )
    print( " # Output from calculate_nmr_shieldings:" )
    if label:
        print( " # ", label )
    print( " # " )

    if ghost_coords is None:
        nmr_results = adfnmrjob(results, active_atoms, out='all', use='FXC', calc='all', u1k='best').run()
    else:
        # remember to add ghosts in SCF step (as ghosts to a system or as pointcharges)
        nmr_results = adfnmrjob(results, active_atoms, ghosts=ghost_coords, out='all', use='FXC', calc='all', u1k='best').run()

    results_para = {}
    results_dia  = {}
    results_tot  = {}
    results_para_aniso = {}
    results_dia_aniso  = {}
    results_tot_aniso  = {}

    if active_atoms is not None:
        for a in range(len(active_atoms)):
            ax = str(active_coords[a][0])
            ay = str(active_coords[a][1])
            az = str(active_coords[a][2])
            coords = ax+", "+ay+", "+az
            tot,para,dia,tot_aniso,para_aniso,dia_aniso = nmr_results.get_shielding(nuc=active_atoms[a])

            if print_active:
                print( "NMR results for an active atom: ", active_atoms[a], " at coords: "+coords+"\n" )
                print( "@@ Shielding_iso_para  "+active_labels[a]+"("+label+") :", para )
                print( "@@ Shielding_iso_dia   "+active_labels[a]+"("+label+") :", dia )
                print( "@@ Shielding_iso_total "+active_labels[a]+"("+label+") :", tot )
                print( "\n" )
                print( "@@ Shielding_aniso_para  "+active_labels[a]+"("+label+") :", para_aniso )
                print( "@@ Shielding_aniso_dia   "+active_labels[a]+"("+label+") :", dia_aniso )
                print( "@@ Shielding_aniso_total "+active_labels[a]+"("+label+") :", tot_aniso )
                print( "\n" )

            results_para[coords] = para
            results_dia[coords] = dia
            results_tot[coords] = tot
            results_para_aniso[coords] = para_aniso
            results_dia_aniso[coords] = dia_aniso
            results_tot_aniso[coords] = tot_aniso

    if ghost_coords is not None:
        for g in range(len(ghost_coords)):
            cx = str(ghost_coords[g][0])
            cy = str(ghost_coords[g][1])
            cz = str(ghost_coords[g][2])
            coords = cx+", "+cy+", "+cz
            tot,para,dia,tot_aniso,para_aniso,dia_aniso = nmr_results.get_shielding(ghost=g+1)

            if print_ghost:
                print( "NMR results at ghost coords: "+coords+"\n" )
                print( "## Shielding_iso_para  : ("+label+") :", para )
                print( "## Shielding_iso_dia   : ("+label+") :", dia )
                print( "## Shielding_iso_total : ("+label+") :", tot )
                print( "\n" )
                print( "@@ Shielding_aniso_para  : ("+label+") :", para_aniso )
                print( "@@ Shielding_aniso_dia   : ("+label+") :", dia_aniso )
                print( "@@ Shielding_aniso_total : ("+label+") :", tot_aniso )
                print( "\n" )

            results_para[coords] = para
            results_dia[coords] = dia
            results_tot[coords] = tot
            results_para_aniso[coords] = para_aniso
            results_dia_aniso[coords] = dia_aniso
            results_tot_aniso[coords] = tot_aniso

    print( " # -- end of calculate_nmr_shieldings -- #" )
    return results_para, results_dia, results_tot, results_para_aniso, results_dia_aniso, results_tot_aniso



##########################################################
# the work starts here
##########################################################

# -----
# setup
# -----

# adapt this path to your directory in $PLG_GROUPS_STORAGE/plggqcembed/
data_dir='/net/pr2/projects/plgrid/plggqcembed/gosia-storage/pyadf/tests/pyadf_scripts/test_usage_response_properties/nmr_shieldings'

if not os.path.exists(data_dir):
    os.makedirs(data_dir)

# do not change this:
from pyadf import *
if 'pyadfenv' not in globals():
    from pyadf.Initialization import *

DefaultJobRunner.instance = None
job_runner_conf = JobRunnerConfiguration(conffile='/net/pr2/projects/plgrid/plggqcembed/devel/tools/pyadf-jobrunner.conf',
                                         jobbasedir=pyadfenv.outdir)
DefaultJobRunner(conf=job_runner_conf)

# adapt molecular data:
# here: play with partitioning schemes:
geometries_dir = os.path.join(pyadfenv.outdir, 'coordinates')
file_mol  = os.path.join(geometries_dir, 'an.xyz')
file_h2o  = os.path.join(geometries_dir, 'solvent0.xyz')
file_env1 = os.path.join(geometries_dir, 'solvent1.xyz')
file_env2 = os.path.join(geometries_dir, 'solvent2.xyz')
file_env3 = os.path.join(geometries_dir, 'solvent3.xyz')
m_mol  = molecule(file_mol)
m_h2o  = molecule(file_h2o)
m_env1 = molecule(file_env1)
m_env2 = molecule(file_env2)
m_env3 = molecule(file_env3)
# also: group "envX" molecules into an entire solvent:
m_e = []
for i in range(1,4):
    m = molecule(os.path.join(geometries_dir, f'solvent{i:d}.xyz'))
    m_e.append(m)
m_env = sum(m_e)
# ...and entire supermolecule:
m_tot = m_mol + m_h2o + m_env1 + m_env2 + m_env3

# if a system is charged, then remember to set it up 
#charge_mol=0
#m_mol.set_charge(charge_mol)
#m_tot.set_charge(charge_mol)

# ask the program not to identify molecular symmetry
m_mol.set_symmetry('NOSYM')
m_h2o.set_symmetry('NOSYM')
m_env1.set_symmetry('NOSYM')
m_env2.set_symmetry('NOSYM')
m_env3.set_symmetry('NOSYM')
m_env.set_symmetry('NOSYM')
m_tot.set_symmetry('NOSYM')

print('Coordinates of all (sub)systems:')
print('mol:')
print(m_mol.print_coordinates())
print('h2o:')
print(m_h2o.print_coordinates())
print('env1:')
print(m_env1.print_coordinates())
print('env2:')
print(m_env2.print_coordinates())
print('env3:')
print(m_env3.print_coordinates())
print('entire environment:')
print((m_h2o+m_env).print_coordinates())
print('entire system:')
print(m_tot.print_coordinates())


# general settings for ADF job - adapt these as needed:
# search in pyadf code to find out what they mean 

settings = adfsettings()

settings.set_ZORA(ZORA=True, SpinOrbit=False)
settings.set_unrestricted(False)
settings.set_functional('PBE')                 # choose DFT functional
basis_set = "DZP"                              # choose the basis set

# these settings can be left as they are:
settings.ncycles=1000                     
settings.set_integration(accint=8.0, acclist=[8.0, 8.0])
settings.set_dependency(True)
settings.set_exactdensity(True)
settings.set_save_tapes([21,10,41])
settings.set_occupations(['KEEPORBITALS '+str(settings.ncycles)])
gen_sym_opts = ['NOSYM', 'NOSYMFIT', 'NUCLEARMODEL gaussian']

# general settings for NMR job - adapt these as needed:

# (1) select NMR centers:
#     here, you can select nuclei for which the NMR shielding is calculated
#       * it can reduce the computational time, otherwise the code does calculations on all nuclei
#       * the numbering order of atoms:
#          * it should be given in "input order" (=as in your xyz files)
#          * atom numbering starts from 1

# select nuclei in an active subsystem
# here - we select C and N
active_nmr_atoms_index = [1,2]
active_nmr_atoms_label = ["C","N"]
active_nmr_atoms_coords= []
for i in active_nmr_atoms_index:
    active_nmr_atoms_coords.append(m_mol.get_coordinates()[i-1])

# select nuclei in an environment;
# here - we select H engaged in a hydrogen bonding
h2o_nmr_atoms_index = [3]
h2o_nmr_atoms_label = ["Hb"]
h2o_nmr_atoms_coords= []
for i in h2o_nmr_atoms_index:
    h2o_nmr_atoms_coords.append(m_h2o.get_coordinates()[i-1])
# we have no interest in nuclei of env:
env_nmr_atoms_index = []
env_nmr_atoms_label = []
env_nmr_atoms_coords= []
for i in env_nmr_atoms_index:
    env_nmr_atoms_coords.append(m_env.get_coordinates()[i-1])

# in a supermolecule, these nuclei have indices 1,2,9
# as in this example, we construct "m_tot" as (in order) "m_mol" (first) + "m_h2o" (second) + "m_env1" (third) ... 
super_nmr_atoms_index = [1,2,9]
super_nmr_atoms_label = ["C", "N", "Hb"]
super_nmr_atoms_coords= []
for i in super_nmr_atoms_index:
    super_nmr_atoms_coords.append(m_tot.get_coordinates()[i-1])


# (2) setup of NMR job is done in calculate_nmr_shieldings function

# general settings for FDE - adapt as needed:

fde_nadd_kin = 'PW91K'    # choose the potential for the non-additive kinetic part of interaction energy
max_fnt_cycles = 10       # choose the maximum number of freeze-and-thaw cycles
save_potentials_densities = False

fde_exc_opts = ['QTENS', 'ALLOW POSHOMO']
gen_fde_opts = gen_sym_opts + fde_exc_opts

fde_act_opts = {'FULLGRID':'', 'TNAD':fde_nadd_kin, 'ENERGY':''}
fde_frz_opts = {}

fnt_act_opts = {'FULLGRID':'', 'TNAD':fde_nadd_kin, 'ENERGY':'', 'RELAXCYCLES': max_fnt_cycles }
fnt_frz_opts = {"RELAX":""}

basis_act = basis_set
basis_frz = basis_set


# ------------------------------------------------------------------
# run calculations on an entire system ("supermolecular" reference):
# ------------------------------------------------------------------

r_tot  = adfsinglepointjob(m_tot,  basis_set, settings=settings, options=gen_sym_opts).run()
agrid = adfgrid(r_tot)
calculate_nmr_shieldings(m_tot, r_tot, active_atoms=super_nmr_atoms_index,  active_labels=super_nmr_atoms_label, active_coords=super_nmr_atoms_coords, label="supermolecule", print_active=True)

# ------------------------------------------------
# run calculations on isolated subsystems (no FDE)
# Note: here we play with different paritioning 
#       schemes, so adapt to your needs;
#       here, we basically have:
#       m_tot = m_mol + m_h2o + m_env
#       and we focus on NMR of:
#         * "C" and "N" in m_mol
#         * "H" in m_h2o involved in H-bond ("Hb")
# ------------------------------------------------

# (1) mol: NMR of C and N in an isolated mol
r_mol  = adfsinglepointjob(m_mol,  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_mol, r_mol, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="isolated mol", print_active=True)

#     ...the same, but we add all atoms of entire environment as ghosts
r_mol  = adfsinglepointjob(m_mol.add_as_ghosts(m_h2o+m_env),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_mol, r_mol, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="isolated mol with entire env as ghosts", print_active=True)

#     ...the same, but we add atoms of the nearest h2o as ghosts:
r_mol  = adfsinglepointjob(m_mol.add_as_ghosts(m_h2o),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_mol, r_mol, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="isolated mol with nearest h2o as ghosts", print_active=True)



# (2) h2o: NMR of "Hb" in an isolated h2o
r_h2o = adfsinglepointjob(m_h2o, basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o", print_active=True)

#     ...the same, but we add all atoms of other molecules as ghosts:
r_h2o  = adfsinglepointjob(m_h2o.add_as_ghosts(m_mol + m_env),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o with other molecules as ghosts", print_active=True)

#     ...the same, but we add mol as ghosts:
r_h2o  = adfsinglepointjob(m_h2o.add_as_ghosts(m_mol),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o with mol as ghosts", print_active=True)



# (3) env: NMR of env;
#     NOTE: in env we did not select any active nuclei to look at; 
#     so what we want to do is to assess the shielding at the positions of "C" and "N" that is due to magnetic perturbation in "env",
#     this is the "NICS-type contribution" to shielding;
#     this means that we need to add "C" and "N" as point charges:
r_env_to_mol = adfsinglepointjob(m_env, basis_set, settings=settings, options=gen_sym_opts, pointcharges=active_nmr_atoms_coords).run()
calculate_nmr_shieldings(m_env, r_env_to_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=active_nmr_atoms_coords, label="isolated env: NICS-like contribution from env to mol", print_active=True)

#     ...the same, but we add mol as ghosts (so in this case, no need to add pointcharges):
r_env_to_mol  = adfsinglepointjob(m_env.add_as_ghosts(m_mol),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_env, r_env_to_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=active_nmr_atoms_coords, label="isolated env with mol as ghosts: NICS-like contribution from env to mol", print_active=True)



# (4) h2o: NMR of "Hb" in an isolated h2o
r_h2o = adfsinglepointjob(m_h2o, basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o", print_active=True)

#     ...the same, but we add all atoms of other molecules as ghosts:
r_h2o  = adfsinglepointjob(m_h2o.add_as_ghosts(m_mol + m_env),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o with other molecules as ghosts", print_active=True)

#     ...the same, but we add mol as ghosts:
r_h2o  = adfsinglepointjob(m_h2o.add_as_ghosts(m_mol),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_h2o, r_h2o, active_atoms=h2o_nmr_atoms_index, active_labels=h2o_nmr_atoms_label, active_coords=h2o_nmr_atoms_coords, label="isolated h2o with mol as ghosts", print_active=True)



#
# At this stage, we can already assess:
# * reference 'solvent shift' on "C" and "N" from mol:
#   * delta1 = "supermolecule" - ("isolated mol" + "isolated env")
#   * delta2 = "supermolecule" - ("isolated mol with entire env as ghosts" + "isolated h2o with other molecules as ghosts")
#


# NICS-type contributions to values calculated above
# (3) sub1: contributions to NMR shielding of C and N from the entire environment
#     note: here we add pointcharges in positions of "C" and "N", so we need to redo the SCF step
#     first, no ghosts:
r_env_total = adfsinglepointjob(m_h2o+m_env, basis_set, settings=settings, options=gen_sym_opts, pointcharges=active_nmr_atoms_coords).run()
calculate_nmr_shieldings(m_h2o+m_env, r_env_total, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=active_nmr_atoms_coords, label="isolated mol: NICS-like contribution from entire solvent (no ghosts)", print_ghost=True)

#     then, with ghosts in positions of "C" and "N"
r_env_total = adfsinglepointjob(m_h2o+m_env.add_as_ghosts(m_mol), basis_set, settings=settings, options=gen_sym_opts, pointcharges=active_nmr_atoms_coords).run()
calculate_nmr_shieldings(m_h2o+m_env, r_env_total, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=active_nmr_atoms_coords, label="isolated mol: NICS-like contribution from entire solvent (mol as ghosts)", print_ghost=True)


#HERE-RESTART
# (4) h2o: contributions to NMR shielding of "Hb" from "mol" (NICS-type contributions to NMR shieldings)
#     note: here we add ghosts as point charges, so we need to redo the SCF step
ghost_coords = h2o_nmr_atoms_coords   # placing ghost centers in positions of "Hb"
r_mol = adfsinglepointjob(m_mol, basis_set, settings=settings, options=gen_sym_opts, pointcharges=ghost_coords).run()
calculate_nmr_shieldings(m_mol, r_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="isolated h2o: NICS-like contribution from mol", print_ghost=True)

# (6) env: contributions to NMR shielding of "Hb" and "Hsolv" from "mol" (NICS-type contributions to NMR shieldings)
#     note: here we add ghosts as point charges, so we need to redo the SCF step
ghost_coords = env_nmr_atoms_coords   # placing ghost centers in positions of "Hb" and "Hsolv"
r_mol = adfsinglepointjob(m_mol, basis_set, settings=settings, options=gen_sym_opts, pointcharges=ghost_coords).run()
calculate_nmr_shieldings(m_mol, r_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="isolated entire solvent: NICS-like contribution from mol", print_ghost=True)

# (3) an example showing how to calculate contributions from a molecule, in which we are not interested (e.g. NICS-type only)
r_env1 = adfsinglepointjob(m_env1, basis_set, settings=settings, options=gen_sym_opts, , pointcharges=nmr_ghosts).run()
calculate_nmr_shieldings(m_env, r_env, active_atoms=env_nmr_atoms_index, active_labels=env_nmr_atoms_label, active_coords=env_nmr_atoms_coords, label="isolated entire solvent", print_active=True)

#     ...the same, but we add all atoms of other molecules as ghosts:
r_env  = adfsinglepointjob(m_env.add_as_ghosts(m_mol + m_h2o),  basis_set, settings=settings, options=gen_sym_opts).run()
calculate_nmr_shieldings(m_env, r_env, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="isolated entire solvent with mol as ghosts", print_active=True)


#

#
# Note: Below, I demonstrate FDE examples;
# adapt this to other partitioning schemes as needed
#

# --------------------
# run FDE calculations
# --------------------

# (1) mol as an "active" subsystem, "env" as a frozen environment
frags = [ fragment(None,  [m_mol]), 
          fragment(r_env, [m_env], isfrozen=True, fdeoptions=fde_frz_opts) ]

ghost_coords = active_nmr_atoms_coords # placing ghost centers in positions of "C" and "N" in an active subsystem

# no ghosts:
result_fde_mol = adffragmentsjob(frags, basis_set, settings=settings, fde=fde_act_opts, options=gen_fde_opts).run()
calculate_nmr_shieldings(m_mol, result_fde_mol, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="FDE mol: mol=active, env=frozen", print_active=True)
# * NICS-type contributions to NMR shieldings from env:
#result_fde_mol = adffragmentsjob(frags, basis_set, settings=settings, fde=fde_act_opts, options=gen_fde_opts, pointcharges=ghost_coords).run()
calculate_nmr_shieldings(m_env, result_fde_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="FDE mol: NICS-like contribution from env (frozen) to mol (active)", print_ghost=True)


# (2) now exchange subsystems and do FDE calculations on an "environment"
frags = [ fragment(None,  [m_env]), fragment(r_mol, [m_mol], isfrozen=True, fdeoptions=fde_frz_opts) ]
ghost_coords = env_nmr_atoms_coords # placing ghost centers in positions of "Hb" and "Hsolv"

result_fde_env = adffragmentsjob(frags, basis_set, settings=settings, fde=fde_act_opts, options=gen_fde_opts).run()
calculate_nmr_shieldings(m_env, result_fde_env, active_atoms=env_nmr_atoms_index, active_labels=env_nmr_atoms_label, active_coords=env_nmr_atoms_coords, label="FDE env: env=active, mol=frozen", print_active=True)
# * NICS-type contributions to NMR shieldings from mol:
#result_fde_env = adffragmentsjob(frags, basis_set, settings=settings, fde=fde_act_opts, options=gen_fde_opts, pointcharges=ghost_coords).run()
calculate_nmr_shieldings(m_mol, result_fde_env, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="FDE env: NICS-like contribution from mol (frozen) to env (active)", print_ghost=True)

## ------------------------------------------------
## run FDE calculations with freeze-and-thaw cycles
## ------------------------------------------------
#
## (1) mol as an "active" subsystem, "env" as environment
#frags = [ fragment(None,  [m_mol]), fragment(r_env, [m_env], isfrozen=True, fdeoptions=fnt_frz_opts) ]
#ghost_coords = active_nmr_atoms_coords # placing ghost centers in positions of "C" and "N"
#
#result_fnt_mol = adffragmentsjob(frags, basis_set, settings=settings, fde=fnt_act_opts, options=gen_fde_opts, pointcharges=ghost_coords).run()
#calculate_nmr_shieldings(m_mol, result_fnt_mol, active_atoms=active_nmr_atoms_index, active_labels=active_nmr_atoms_label, active_coords=active_nmr_atoms_coords, label="FnT mol: mol=active, env=frozen", print_active=True)
## * NICS-type contributions to NMR shieldings from env
#calculate_nmr_shieldings(m_env, result_fnt_mol, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="FnT mol: NICS-like contribution from env (frozen) to mol (active)", print_ghost=True)
#
#
## (2) now exchange subsystems and do FDE calculations on an "environment"
#
#frags = [ fragment(None,  [m_env]), fragment(r_mol, [m_mol], isfrozen=True, fdeoptions=fnt_frz_opts) ]
#ghost_coords = env_nmr_atoms_coords   # placing ghost centers in positions of "Hb" and "Hsolv"
#
#result_fnt_env = adffragmentsjob(frags, basis_set, settings=settings, fde=fnt_act_opts, options=gen_fde_opts, pointcharges=ghost_coords).run()
#
#calculate_nmr_shieldings(m_env, result_fnt_env, active_atoms=env_nmr_atoms_index, active_labels=env_nmr_atoms_label, active_coords=env_nmr_atoms_coords, label="FnT env: env=active, mol=frozen", print_active=True)
## * NICS-type contributions to NMR shieldings from mol:
#calculate_nmr_shieldings(m_mol, result_fnt_env, active_atoms=[], active_labels=[], active_coords=[], ghost_coords=ghost_coords, label="FnT env: NICS-like contribution from mol (frozen) to env (active)", print_ghost=True)
#
#
#
